Author: Ray Strode <rstrode@redhat.com>
Description:
 [main] drop all the open strstr calls
 .
 Our kernel command line processing is rather ad hoc.
 This commit tries to clean it up a small amount by
 adding functions to hide the strstr details.
 .
 [main] Use plymouth.arg instead of plymouth:arg for kernel cmdline
 .
 Plymouth has historically used "plymouth:" to identify arguments destined
 for it on the kernel command line.  Most other things seem to the period
 instead of colon, so this commit just makes plymouth conform.
 .
 For compatibility, we still support the old way.
 .
 [main] Try to be smarter about init=/foo on kernel command line
 .
 Right now, we put plymouth into a sort of degraded mode when we
 find init=/anything on the kernel command line.  This is so if
 the user does init=/bin/sh to get fix their system, we don't
 get in the way.
 .
 This breaks plymouth for things like init=/sbin/bootchartd and even
 init=/sbin/init.  We've previously had a plymouth.override-splash
 kernel command line option to force plymouth on in those cases.
 .
 This commit flips things around a bit.  Now init=/sbin/bootchartd
 will work by default and there's a new option
 plymouth.ignore-show-splash which forces things back into degraded
 mode.  We also will implicitly do the degraded mode for e.g.
 init=/foo/barsh
 .
 [main] Don't watch for keyboard input if no keyboard
 .
 In the event should_ignore_show_splash_calls () returns
 true, we won't ever have a keyboard set.  This commit
 make sure that we don't try to use the keyboard if its
 unavailable.
 .
 [main] Parse args at end of /proc/cmdline properly
 .
 We weren't treating \n as an acceptable boundary

diff -Naurp plymouth.orig/src/main.c plymouth/src/main.c
--- plymouth.orig/src/main.c	2010-09-10 23:30:09.034714601 +0200
+++ plymouth/src/main.c	2010-09-14 21:16:20.846252733 +0200
@@ -23,6 +23,7 @@
 
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <ctype.h>
 #include <limits.h>
 #include <dirent.h>
 #include <fcntl.h>
@@ -206,29 +207,65 @@ show_detailed_splash (state_t *state)
     }
 }
 
+static const char *
+command_line_get_string_after_prefix (const char *command_line,
+                                      const char *prefix)
+{
+  char *argument;
+
+  argument = strstr (command_line, prefix);
+
+  if (argument == NULL)
+    return NULL;
+
+  if (argument == command_line ||
+      argument[-1] == ' ')
+    return argument + strlen (prefix);
+
+  return NULL;
+}
+
+static bool
+command_line_has_argument (const char *command_line,
+                           const char *argument)
+{
+    const char *string;
+
+    string = command_line_get_string_after_prefix (command_line, argument);
+
+    if (string == NULL)
+      return false;
+
+    if (!isspace ((int) string[0]) && string[0] != '\0')
+      return false;
+
+    return true;
+}
+
 static void
 find_override_splash (state_t *state)
 {
-  char *splash_string;
+  const char *splash_string;
 
   if (state->override_splash_path != NULL)
       return;
 
-  splash_string = strstr (state->kernel_command_line, "plymouth:splash=");
+  splash_string = command_line_get_string_after_prefix (state->kernel_command_line,
+                                                        "plymouth.splash=");
 
   if (splash_string != NULL)
     {
-      char *end;
-      splash_string = strdup (splash_string + strlen ("plymouth:splash="));
+      const char *end;
+      int length;
 
       end = splash_string + strcspn (splash_string, " \n");
-      *end = '\0';
+      length = end - splash_string;
 
-      ply_trace ("Splash is configured to be '%s'", splash_string);
+      ply_trace ("Splash is configured to be '%*.*s'", length, length, splash_string);
 
       asprintf (&state->override_splash_path,
-                PLYMOUTH_THEME_PATH "%s/%s.plymouth",
-                splash_string, splash_string);
+                PLYMOUTH_THEME_PATH "%*.*s/%*.*s.plymouth",
+                length, length, splash_string, length, length, splash_string);
     }
 }
 
@@ -602,11 +639,23 @@ on_error (state_t *state)
 static bool
 plymouth_should_ignore_show_splash_calls (state_t *state)
 {
+  const char *init_string;
+  size_t length;
+
   ply_trace ("checking if plymouth should be running");
-  if (state->mode != PLY_MODE_BOOT || ply_string_has_prefix (state->kernel_command_line, "plymouth:force-splash") || strstr (state->kernel_command_line, " plymouth:force-splash") != NULL)
+  if (state->mode != PLY_MODE_BOOT || command_line_has_argument (state->kernel_command_line, "plymouth.force-splash"))
       return false;
 
-  return ply_string_has_prefix (state->kernel_command_line, "init=") || strstr (state->kernel_command_line, " init=") != NULL;
+  if (command_line_has_argument (state->kernel_command_line, "plymouth.ignore-show-splash"))
+      return true;
+
+  init_string = command_line_get_string_after_prefix (state->kernel_command_line, "init=");
+
+  length = strcspn (init_string, " \n");
+  if (length > 2 && ply_string_has_prefix (init_string + length - 2, "sh"))
+    return true;
+
+  return false;
 }
 
 static bool
@@ -615,12 +664,7 @@ plymouth_should_show_default_splash (sta
   ply_trace ("checking if plymouth should show default splash");
 
   const char const *strings[] = {
-      " single ", " single\n", "^single ",
-      " 1 ", " 1\n", "^1 ",
-      " s ", " s\n", "^s ",
-      " S ", " S\n", "^S ",
-      " -s ", " -s\n", "^-s ",
-      NULL
+      "single", "1", "s", "S", "-S", NULL
   };
   int i;
 
@@ -629,21 +673,33 @@ plymouth_should_show_default_splash (sta
 
   for (i = 0; strings[i] != NULL; i++)
     {
-      int cmp;
-      if (strings[i][0] == '^')
-          cmp = strncmp(state->kernel_command_line, strings[i]+1,
-                        strlen(strings[i]+1)) == 0;
-      else
-          cmp = strstr (state->kernel_command_line, strings[i]) != NULL;
-
-      if (cmp)
+      if (command_line_has_argument (state->kernel_command_line, strings[i]))
         {
-          ply_trace ("kernel command line has option \"%s\"", strings[i]);
+          ply_trace ("no default splash because kernel command line has option \"%s\"", strings[i]);
           return false;
         }
     }
 
-  return strstr (state->kernel_command_line, "rhgb") != NULL || (strstr (state->kernel_command_line, "splash") != NULL && strstr(state->kernel_command_line, "splash=verbose") == NULL);
+  if (command_line_has_argument (state->kernel_command_line, "splash=verbose"))
+    {
+      ply_trace ("no default splash because kernel command line has option \"splash=verbose\"");
+      return false;
+    }
+
+  if (command_line_has_argument (state->kernel_command_line, "rhgb"))
+    {
+      ply_trace ("using default splash because kernel command line has option \"rhgb\"");
+      return true;
+    }
+
+  if (command_line_has_argument (state->kernel_command_line, "splash"))
+    {
+      ply_trace ("using default splash because kernel command line has option \"splash\"");
+      return true;
+    }
+
+  ply_trace ("no default splash because kernel command line lacks \"splash\" or \"rhgb\"");
+  return false;
 }
 
 static void
@@ -1449,7 +1505,8 @@ start_boot_splash (state_t    *state,
       return NULL;
     }
 
-  ply_keyboard_watch_for_input (state->keyboard);
+  if (state->keyboard != NULL)
+    ply_keyboard_watch_for_input (state->keyboard);
 
   update_display (state);
   return splash;
@@ -1511,6 +1568,8 @@ static bool
 get_kernel_command_line (state_t *state)
 {
   int fd;
+  const char *remaining_command_line;
+  char *key;
 
   ply_trace ("opening /proc/cmdline");
   fd = open ("proc/cmdline", O_RDONLY);
@@ -1528,7 +1587,22 @@ get_kernel_command_line (state_t *state)
       return false;
     }
 
+
+  /* we now use plymouth.argument for kernel commandline arguments.
+   * It used to be plymouth:argument. This bit just rewrites all : to be .
+   */
+  remaining_command_line = state->kernel_command_line;
+  while ((key = strstr (remaining_command_line, "plymouth:")) != NULL)
+    {
+      char *colon;
+
+      colon = key + strlen ("plymouth");
+      *colon = '.';
+
+      remaining_command_line = colon + 1;
+    }
   ply_trace ("Kernel command line is: '%s'", state->kernel_command_line);
+
   close (fd);
   return true;
 }
@@ -1536,15 +1610,14 @@ get_kernel_command_line (state_t *state)
 static void
 check_verbosity (state_t *state)
 {
-  char *path;
+  const char *path;
 
   ply_trace ("checking if tracing should be enabled");
 
-  path = NULL;
-  if ((strstr (state->kernel_command_line, " plymouth:debug ") != NULL)
-     || (strstr (state->kernel_command_line, "plymouth:debug ") != NULL)
-     || (path = strstr (state->kernel_command_line, " plymouth:debug=file:")) != NULL
-     || (strstr (state->kernel_command_line, " plymouth:debug") != NULL))
+  path = command_line_get_string_after_prefix (state->kernel_command_line,
+                                               "plymouth.debug=file:");
+  if (path != NULL ||
+      command_line_has_argument (state->kernel_command_line, "plymouth.debug"))
     {
 #ifdef LOG_TO_DEBUG_FILE
       int fd;
@@ -1558,7 +1631,6 @@ check_verbosity (state_t *state)
         {
           char *end;
 
-          path += strlen (" plymouth:debug=file:");
           debug_buffer_path = strdup (path);
           end = debug_buffer_path + strcspn (debug_buffer_path, " \n");
           *end = '\0';
@@ -1593,9 +1665,7 @@ check_logging (state_t *state)
 {
   ply_trace ("checking if console messages should be redirected and logged");
 
-  if ((strstr (state->kernel_command_line, " plymouth:nolog ") != NULL)
-     || (strstr (state->kernel_command_line, "plymouth:nolog ") != NULL)
-     || (strstr (state->kernel_command_line, " plymouth:nolog") != NULL))
+  if (command_line_has_argument (state->kernel_command_line, "plymouth.nolog"))
     {
       ply_trace ("logging won't be enabled!");
       state->no_boot_log = true;
@@ -1612,29 +1682,31 @@ check_for_consoles (state_t    *state,
                     const char *default_tty,
                     bool        should_add_displays)
 {
-  char *console_key;
-  char *remaining_command_line;
+  const char *console;
+  const char *remaining_command_line;
 
   ply_trace ("checking for consoles%s",
              should_add_displays? " and adding displays": "");
 
   remaining_command_line = state->kernel_command_line;
-  while ((console_key = strstr (remaining_command_line, " console=")) != NULL)
+
+  while ((console = command_line_get_string_after_prefix (remaining_command_line,
+                                                          "console=")) != NULL)
     {
       char *end;
       ply_trace ("serial console found!");
 
       free (state->kernel_console_tty);
-      state->kernel_console_tty = strdup (console_key + strlen (" console="));
+      state->kernel_console_tty = strdup (console);
 
-      remaining_command_line = console_key + strlen (" console=");
+      remaining_command_line = console;
 
       end = strpbrk (state->kernel_console_tty, " \n\t\v,");
 
       if (end != NULL)
         {
           *end = '\0';
-          remaining_command_line += end - state->kernel_console_tty;
+          console += end - state->kernel_console_tty;
         }
 
       if (strcmp (state->kernel_console_tty, "tty0") == 0 || strcmp (state->kernel_console_tty, "/dev/tty0") == 0)
